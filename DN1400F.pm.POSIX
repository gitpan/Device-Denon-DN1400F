package Device::Denon::DN1400F;

use 5.006;
use strict;
use vars qw($VERSION @EXPORT_OK %EXPORT_TAGS %COMMANDS);
use warnings;
use Exporter;
use Data::Dumper;
use POSIX qw(:errno_h :fcntl_h :termios_h);
use Time::HiRes qw(usleep);

our @ISA = qw(Exporter);

# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.

@EXPORT_OK = qw();
%EXPORT_TAGS = ('all' => \@EXPORT_OK);
$VERSION = '0.01';

%COMMANDS = (
	MOVE_FRONT				=> {
			Command	=> [ qw(ID 0xb2) ],
			Answer	=> [ qw(0x80 ID) ],
			Busy	=> [ qw(INVD ID) ],
				},
	CLEAR_CHANGER_BUFFER	=> {
			Command	=> [ qw(ID 0xC0) ],
			Answer	=> [ qw(0x80 ID) ],
			Busy	=> [ qw(INVD ID) ],
				},
	_1BYTE_ERROR_CODE		=> {
			Command	=> [ qw(ID 0xC1) ],
			Answer	=> [ qw(ERR0 ID) ],
			Busy	=> [ qw(INVD ID) ],
				},
	_2BYTE_ERROR_CODE		=> {
			Command	=> [ qw(ID 0xC2) ],
			Answer	=> [ qw(ERR0 ERR1 ID) ],
			Busy	=> [ qw(INVD ID) ],
				},
	DISC_NUMBER				=> {
			Command	=> [ qw(ID 0xC3) ],
			Answer	=> [ qw(DNO_F DNO_R ID) ],
			Busy	=> [ qw(INVD ID) ],
				},
	SELECT_A_DISC			=> {
			Command	=> [ qw(ID 0xC4 DSCP DSCN DID) ],
			Answer	=> [ qw(CST0 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	RETURN_A_DISC			=> {
			Command	=> [ qw(ID 0xC5 DSCP DSCN DID) ],
			Answer	=> [ qw(CST0 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	RETURN_ALL_DISC			=> {
			Command	=> [ qw(ID 0xC6) ],
			Answer	=> [ qw(CST0 ID) ],
			Busy	=> [ qw(INVD ID) ],
				},
	RESET_DN_1400F			=> {
			Command	=> [ qw(ID 0xCA) ],
			Answer	=> [ qw() ],
			Busy	=> [ qw(INVD ID) ],
				},
	CHANGER_MICON_VERSION	=> {
			Command	=> [ qw(ID 0xCB 0x00) ],
			Answer	=> [ qw(VER0 VER1 ID) ],
			Busy	=> [ qw(INVD ID) ],
				},
	DISCNUMBER_CHANGER_STATUS=>{
			Command	=> [ qw(ID 0xCC) ],
			Answer	=> [ qw(DSC_P DSC_N CST0 DSC_P DSC_N CST0 CST1 ID)],
			Busy	=> [ qw(INVD ID) ],
				},
	DRIVE_STATUS			=> {
			Command	=> [ qw(ID 0xCB DID) ],
			Answer	=> [ qw(DST0 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	DRIVE_MICON_VERSION		=> {
			Command	=> [ qw(ID 0xD1 DID) ],
			Answer	=> [ qw(VER0 VER1 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	DRIVE_STATUS_SERVOONOFF	=> {
			Command	=> [ qw(ID 0xD2 DID) ],
			Answer	=> [ qw(DST0 DST_1 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	SUB_CODE_QMODE3			=> {
			Command	=> [ qw(ID 0xD6 DID) ],
			Answer	=> [ qw(DST0 CTR_L),
						map{"ISRC_$_"}(0..7),
						qw(AFR_M ID DID)],
			Busy	=> [ qw(INVD ID DID) ],
				},
	SUB_CODE_QMODE2			=> {
			Command	=> [ qw(ID 0xD7 DID) ],
			Answer	=> [ qw(DST0 CTR_L),
						map{"UPC_$_"}(0..7),
						qw(AFR_M ID DID)],
			Busy	=> [ qw(INVD ID DID) ],
				},
	SUB_CODE_QCHANNEL		=> {
			Command	=> [ qw(ID 0xD9 DID) ],
			Answer	=> [ qw(DST0 CTR_L TNO INX MIN SEC FRM 0x00
							AMI_N ASE_C AFR_M ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	ALL_TOC_DATA			=> {
			Command	=> [ qw(ID 0xDA DID) ],
			Answer	=> [ qw(0xA0 PMI_N 0x00 0x00
							CTR_L YADDA EOT 0x00
							YADDA DST0 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	SHORT_TOC_DATA			=> {
			Command	=> [ qw(ID 0xDB DID) ],
			Answer	=> [ qw(0xA0 PMI_N 0x00 0x00
							CTR_L YADDA EOT DST0 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	PLAY_AUDIO			=> {
			Command	=> [ qw(ID 0xE2 AMIN ASEC AFRM TNO INX MODE DID) ],
			Answer	=> [ qw(DST0 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	AUDIO_SCAN			=> {
			Command	=> [ qw(ID 0xE3 AMIN ASEC AFRM TNO INX MODE DID) ],
			Answer	=> [ qw(DST0 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	PAUSE					=> {
			Command	=> [ qw(ID 0xE5 MODE) ],
			Answer	=> [ qw(DST0 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	SEEK					=> {
			Command	=> [ qw(ID 0xE6 AMIN ASEC AFRM DID) ],
			Answer	=> [ qw(DST0 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	STOP					=> {
			Command	=> [ qw(ID 0xE7 MODE) ],
			Answer	=> [ qw(DST0 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	# 25-26 reserved
	TRACK_SEARCH		=> {
			Command	=> [ qw(ID 0xEC AMIN ASEC AFRM TNO INX MODE DID) ],
			Answer	=> [ qw(DST0 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	AUDIO_CHANNEL_CONTROL	=> {
			Command	=> [ qw(ID 0xED) ],
			Answer	=> [ qw(CST0 ID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	# 29 reserved
	FADE_INOUT_PLAY		=> {
			Command	=> [ qw(ID 0xF2 AMIN ASEC AFRM TNO INX MODE DID) ],
			Answer	=> [ qw(DST0 ID DID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
	SYSTEM_MICON_VERSION	=> {
			Command	=> [ qw(ID 0xF3) ],
			Answer	=> [ qw(VER0 VER1 ID) ],
			Busy	=> [ qw(INVD ID DID) ],
				},
		);


sub new {
	my $class = shift;
	my $self = ($#_ == 0) ? { %{ (shift) } } : { @_ };

	die "No SerialPort specified" unless $self->{SerialPort};

	my $fd = POSIX::open($self->{SerialPort}, O_RDWR|O_NOCTTY|O_NONBLOCK);
	die "Failed to open $self->{SerialPort}" if $fd < 0;

	use Carp;
	local $SIG{__WARN__} = sub { confess @_; };

	my $termios = new POSIX::Termios;
	$termios->getattr($fd);
	$termios->setispeed(19200);
	$termios->setospeed(19200);
	my $iflag = $termios->getiflag;
	my $cflag = $termios->getcflag;

	# Set even parity
	# $iflag |= INPCK;
	$iflag |= IGNPAR;	# Or ignore parity errors. PARMRK = mark them
	$cflag |= PARENB;
	$cflag &= ~PARODD;

	# Set 8 data bits
	$cflag &= ~CSIZE;
	$cflag |= CS8;

	# Set 1 stop bit
	$cflag &= ~CSTOPB;

	# No handshake
	$iflag &= ~(IXON | IXOFF);
	# $cflag &= ~CRTSCTS;

	$termios->setiflag($iflag);
	$termios->setcflag($cflag);

	$termios->setattr($fd, &POSIX::TCSANOW());

	$self->{Fd} = $fd;

	return bless $self, $class;
}

sub commands {
	return keys(%COMMANDS);
}

sub _cmd {
	my $self = shift;
	my $command = shift;
	my $args = ($#_ == 0) ? { %{ (shift) } } : { @_ };

	my $data = $COMMANDS{$command};
	die "No such command $command" unless $data;

	my @template = @{ $data->{Command} };
	my @bytes = ();
	foreach (@template) {
		if ($_ =~ /^0x[[:xdigit:]]+$/) {
			push(@bytes, hex($_));
		}
		elsif ($_ eq 'ID') {
			push(@bytes, $self->{Id} + 0x50);
		}
		else {
			die "No value for required parameter $_"
							unless exists $args->{$_};
			push(@bytes, $args->{$_});
		}
	}

	my @hex = map { sprintf("%x", $_) } @bytes;
	my $string = pack("C*", @bytes);
	# my $count = $self->{Port}->write($string);
	print "About to write\n";
	my $count = POSIX::write($self->{Fd}, $string, scalar(@bytes));
	POSIX:tcdrain($self->{Fd});
	print "Wrote $count bytes: @hex : $string\n";
	die "Wrote only $count bytes" unless $count == length $string;

	$string = '';
	# sysread($self->{Port}->{FD}, $string, 20);
	# $string = $self->{Port}->lookfor(2);
	POSIX::read($self->{Fd}, $string, 1);
	$count = defined $string ? length $string : 0;

	# ($count, $string) = $self->{Port}->read(2);
	sleep 1;

	print "Read $count bytes\n";
	die "Got data!" if $count;

	return { } unless $count;

	my @response = unpack("C*", $string);

	if ($response[0] == 0xDD) {
		@template = @{ $data->{Busy} };
	}
	else {
		@template = @{ $data->{Answer} };
	}

	die "Reponse template not same size as response"
					unless @template == @response;

	my %out = map { $template[$_] => $response[$_] } (0..$#template);
	return \%out;
}

sub command {
	my $self = shift;
	my $response = $self->_cmd(@_);
	$self->print_response($response);
	return $response;
}

my %CST0 = (
	0x80	=> "Command complete, reception normally completed.",
	0x81	=> "No Disc",
	0x82	=> "Busy, Disc transport section is in disc transport processing",
	0x83	=> "Completed Disc Set with No Error",
	0x84	=> "Reserved",
	0x85	=> "Reserved",
	0x86	=> "Reserved",
	0x8A	=> "Initial Busy, After power on and Reset DN-1400F",
	0x8B	=> "Changer Error",
	0x8C	=> "Disc Rack in not set",
	0x8E	=> "Wait transportation",
	0x8F	=> "Changer Error",
	0xDD	=> "INVD, Command Busy or Invalid Command",
		);

my %DST0 = (
	0xB0	=> "Ready, Reception normally completed.",
	0xB1	=> "Fade In / Out Play, In the process of fade in/out play",
	0xB2	=> "Seek, In the process of search.",
	0xB3	=> "Reserved",
	0xB4	=> "Pause, Pause condition during audio play.",
	0xB5	=> "Scan, In the process of scan play execution.",
	0xB6	=> "Play, In the process of audio play.",
	0xB7	=> "Reserved",
	0xB8	=> "Disc Change. Disc has been changed.",
	0xB9	=> "No Disc, Disc is not set in the disc loading section.",
	0xBA	=> "Reserved",
	0xBB	=> "Seek Error",
	0xBC	=> "EOT: End of TOC",
	0xBF	=> "CD-ROM Data Area",
	0xD0	=> "RAM Error (CD-DRIVE Hardware Error)",
	0xD1	=> "FOK Error (CD-DRIVE Hardware Error)",
	0xD2	=> "FZC Error (CD-DRIVE Hardware Error)",
	0xD3	=> "GFS Error (CD-DRIVE Hardware Error)",
	0xD5	=> "Slide Error (CD-DRIVE Hardware Error)",
	0xD6	=> "Eject Sequence Error (CD-DRIVE Hardware Error)",
	0xD7	=> "Gain Control Error (CD-DRIVE Hardware Error)",
	0xD8	=> "Reserved",
	0xD9	=> "Reserved",
	0xDA	=> "Reserved",
	0xDB	=> "Invalid Command or Invalid Parameter",
	0xDC	=> "Invalid Parameter",
	0xDD	=> "INVD: Command busy or Invalid Command.",
		);

my %DST1 = (
	0x00	=> "Servo off",
	0x01	=> "Servo on",
		);

my %DID = (
	0x00	=> "Drive 1: Front",
	0x01	=> "Drive 2: Rear",
		);

sub print_response_item {
	my ($self, $response, $key, $values) = @_;
	if ($response->{$key}) {
		my $value = $values
				? ($values->{$key} || "VALUE UNKNOWN!")
				: $response->{$key};
		print "$key: ".sprintf("%x", $response->{$key}) . " : $value\n";
		delete $response->{$key};
	}
}

sub print_response {
	my ($self, $response) = @_;

	my %copy = %$response;
	$self->print_response_item(\%copy, "CST0", \%CST0);
	$self->print_response_item(\%copy, "DST0", \%DST0);
	$self->print_response_item(\%copy, "DST1", \%DST1);
	$self->print_response_item(\%copy, "DID", \%DID);
	foreach (keys %copy) {
		$self->print_response_item(\%copy, $_, undef);
	}
}

sub load_disc {
	my ($self, $drive, $discno, $args) = @_;

	$args->{DID} = $drive;

	if ($discno <= 50) {
		$args->{DSCP} = 0;
		$args->{DSCN} = $discno - 1;
	}
	elsif ($discno <= 100) {
		$args->{DSCP} = 1;
		$args->{DSCN} = $discno - 51;
	}
	elsif ($discno <= 150) {
		$args->{DSCP} = 2;
		$args->{DSCN} = $discno - 101;
	}
	elsif ($discno <= 200) {
		$args->{DSCP} = 3;
		$args->{DSCN} = $discno - 151;
	}
	else {
		die "Invalid disc number $discno\n";
	}
	return $self->command('SELECT_A_DISC', $args);
}

sub play_disc {
	my ($self, $drive, $track, $args) = @_;

	$args->{DID} = $drive;
	$args->{TNO} = $track;
	$args->{MODE} = hex(0x09);
	foreach (qw(AMIN ASEC AFRM INX)) {
		$args->{$_} = 0 unless exists $args->{$_};
	}
	return $self->command('PLAY_AUDIO', $args);
}

sub return_all_disc {
	my ($self) = @_;
	return $self->command('RETURN_ALL_DISC');
}

sub move_front {
	my ($self) = @_;
	return $self->command('MOVE_FRONT');
}

sub reset {
	my ($self) = @_;
	return $self->command('RESET_DN_1400F');
}

sub foo {
	my ($self) = @_;
	return $self->command('_1BYTE_ERROR_CODE');
}

1;

__END__

=head1 NAME

Device::Denon::DN1400F - Perl extension for blah blah blah

=head1 SYNOPSIS

  use Device::Denon::DN1400F;
  blah blah blah

=head1 DESCRIPTION

Stub documentation for Device::Denon::DN1400F, created by h2xs. It looks like the
author of the extension was negligent enough to leave the stub
unedited.

Blah blah blah.

=head2 EXPORT

None by default.


=head1 AUTHOR

A. U. Thor, E<lt>a.u.thor@a.galaxy.far.far.awayE<gt>

=head1 SEE ALSO

L<perl>.

=cut
